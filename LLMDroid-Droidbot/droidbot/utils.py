import re
import functools
from datetime import datetime
from logging import Logger

# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile('^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+'
                                  '(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$')


def lazy_property(func):
    attribute = '_lazy_' + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group('date')
    time = m.group('time')
    log_dict['pid'] = m.group('pid')
    log_dict['tid'] = m.group('tid')
    log_dict['level'] = m.group('level')
    log_dict['tag'] = m.group('tag')
    log_dict['content'] = m.group('content')
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict['datetime'] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess
    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random
    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib
    return hashlib.md5(input_str.encode('utf-8')).hexdigest()


def safe_dict_get(view_dict, key, default=None):
    if view_dict is None:
        return default
    value = view_dict[key] if key in view_dict else None
    return value if value is not None else default


def save_content_to_file(filepath, title: str = '', content: str = '', mode='a', encoding='utf=8'):
    parseline = '-' * 20 + title + '-' * 20
    with open(filepath, mode=mode, encoding=encoding) as file:
        file.write(parseline + '\n')
        file.write(content + '\n')
        file.write('-' * len(parseline) + '\n')


def custom_serializer(obj):
    from .desc.action_type import ActionType
    from .desc.device_state import DeviceState
    from .desc.state_cluster import ActionListener
    from .desc.widget import Widget
    if isinstance(obj, ActionType):
        return obj.string  # 或者返回 obj.value
    elif isinstance(obj, Widget):
        return 'Widget'
    elif isinstance(obj, DeviceState):
        return 'DeviceState'
    elif isinstance(obj, ActionListener):
        return 'ActionListener'
    elif isinstance(obj, Logger):
        return 'Logger'
    else:
        return obj.__dict__
